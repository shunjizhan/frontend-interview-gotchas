# 各种问题
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [各种问题](#各种问题)
  - [React中的合成事件是什么？](#react中的合成事件是什么)
    - [what](#what)
    - [why](#why)
    - [原理](#原理)
  - [React代码复用的三种方式](#react代码复用的三种方式)
    - [高阶组件（HOC）](#高阶组件hoc)
    - [render props](#render-props)
    - [Hook](#hook)
  - [HOC的适用场景](#hoc的适用场景)
  - [对React-Fiber的理解](#对react-fiber的理解)
    - [why](#why-1)
    - [what](#what-1)
  - [Component, Element, Instance 之间有什么区别和联系？](#component-element-instance-之间有什么区别和联系)
  - [UNSAFE的生命周期](#unsafe的生命周期)
    - [componentWillMount](#componentwillmount)
    - [componentWillReceiveProps](#componentwillreceiveprops)
    - [componentWillUpdate](#componentwillupdate)
  - [MVC框架的主要问题是什么？](#mvc框架的主要问题是什么)
  - [Redux遵循的三个原则是什么？](#redux遵循的三个原则是什么)
  - [references](#references)

<!-- /code_chunk_output -->

## React中的合成事件是什么？
### what
合成事件是围绕浏览器原生事件充当跨浏览器包装器的对象。它们将不同浏览器的行为合并为一个 API。

JSX 上写的事件并没有绑定在对应的真实 DOM 上，而是通过事件代理的方式，将所有的事件都统一绑定在了 document 上。另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 event.stopPropagation 是无效的，而应该调用 event.preventDefault。

事件的执行顺序为原生事件先执行，合成事件后执行，合成事件会冒泡绑定到 document 上，所以尽量避免原生事件与合成事件混用，如果原生事件阻止冒泡，可能会导致合成事件不执行，因为需要冒泡到document 上合成事件才会执行。
### why
这样做有两个好处：
- 抹平了浏览器之间的兼容问题，更好的跨平台
- 增加性能和可维护性：对于原生浏览器事件来说，浏览器会给监听器创建一个事件对象。如果你有很多的事件监听，那么就需要分配很多的事件对象，造成高额的内存分配问题。但是对于合成事件来说，有一个事件池专门来管理它们的创建和销毁，当事件需要被使用时，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，从而便于下次复用事件对象。

### 原理
React基于Virtual DOM实现了一个SyntheticEvent层（合成事件层），定义的事件处理器会接收到一个合成事件对象的实例，它符合W3C标准，且与原生的浏览器事件拥有同样的接口，支持冒泡机制，所有的事件都自动绑定在最外层上。

在React底层，主要对合成事件做了两件事：
- 事件委派： React会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。
- 自动绑定： React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。(React.createClass里面才会，es6的class里面不会)


## React代码复用的三种方式
### 高阶组件（HOC）
高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。

HOC接受一个组件和额外的参数（如果需要），返回一个新的组件。HOC 是纯函数，没有副作用。

- 优点∶ 逻辑复用、不影响被包裹组件的内部逻辑。
- 缺点∶ hoc传递给被包裹组件的props容易和被包裹后的组件重名，进而被覆盖。嵌套地狱。

### render props
render props是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术，更具体的说，render prop 是一个用于告知组件需要渲染什么内容的函数 prop。

具有render prop 的组件接受一个返回React元素的函数，将render的渲染逻辑注入到组件内部。在这里，"render"的命名可以是任何其他有效的标识符。
```tsx
class DataProvider extends React.Components {
  state = {
    name: 'Tom'
  }

  render() {
    return (
      <div>
          <p>共享数据组件自己内部的渲染逻辑</p>
          { this.props.render(this.state) }
      </div>
    );
  }
}

// 其实思路有点类似于把child组件当成render函数传给父组件
const renderChild = data => (<h1>Hello { data.name }</h1>);

<DataProvider render={ renderChild }/>
```

- 优点：数据共享、代码复用，将组件内的state作为props传递给调用者，将渲染逻辑交给调用者。
- 缺点：无法在 return 语句外访问数据、嵌套写法不够优雅。嵌套地狱。

### Hook
它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。通过自定义hook，可以复用代码逻辑。

- 使用直观
- 解决hoc的prop 重名问题
- 解决render props 因共享数据 而出现嵌套地狱的问题
- 能在return之外使用数据的问题

## HOC的适用场景
- 代码复用，逻辑抽象
- 渲染劫持
- State 抽象和更改
- Props 更改


## 对React-Fiber的理解
### why
React V15 在渲染时，会递归比对 VirtualDOM 树，找出需要变动的节点，然后同步更新它们， 一气呵成。这个过程期间不可以打断，就会一直占据浏览器资源，这会导致用户触发的事件得不到响应，并且会导致掉帧，导致用户感觉到卡顿。

### what
fiber翻译过来叫做纤维，顾名思义，就是把整个render的过程（主要是dom diff过程）分成像纤维一样的，一个一个的小任务。这些小任务是一个一个进行，并且随时可以打断的，不像一个大的递归任务，是不可以打断的。具体来讲，就是把递归式dom diff，改成迭代式的，通过requestIdleCallback这个api，在浏览器空闲的时间来进行dom diff，从而大大优化了用户体验。

## Component, Element, Instance 之间有什么区别和联系？
- **组件Component：** 可以通过多种方式声明。可以是带有一个render()方法的类，简单点也可以定义为一个函数。这两种情况下，它都把属性props作为输入，把返回的一棵元素树作为输出。
- **元素Element:** 在React里面可以理解为就是vdom的node。它是一个普通对象(plain object)，描述了对于一个DOM节点或者其他组件component，你想让它在屏幕上呈现成什么样子。元素element可以在它的属性props中包含其他元素(译注:用于形成元素树)。创建一个React元素element成本很低。元素element创建之后是不可变的。
- **实例:** 一个实例instance是你在所写的组件类component class中使用关键字this所指向的东西(译注:组件实例)。它用来存储本地状态和响应生命周期事件很有用。

函数式组件(Functional component)根本没有实例instance。类组件(Class component)有实例instance，但是永远也不需要直接创建一个组件的实例，因为React帮我们做了这些。

## UNSAFE的生命周期
有这三个
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate

这里的UNSAFE并不是指安全性，而是表示两个事情：
- 使用这些生命周期的代码将更有可能在未来的React版本中存在缺陷，特别是一旦启用了异步渲染
- 新手容易用法不标准而造成一些问题。

### componentWillMount
componentWillMount生命周期发生在首次渲染前，一般在这里初始化数据或异步获取外部数据赋值。

**问题**
假如组件在第一次渲染的时候被中断，由于组件没有完成渲染，所以并不会执行componentWillUnmount生命周期（componentWillUnmount必须在componenDidMount以后才能被调用），但是componentWillMount里面执行的subscribe就无法被unsubscribe。

**官方推介**
- 初始化数据和subscribe，react官方建议放在constructor里面
- 而异步获取外部数据，放在componentDidMount里面

### componentWillReceiveProps
这个一般是用来同步state和prop。

**问题**
但是用的不规范的话，比如在这里面调用了父组件的updateXXX，可能导致无限循环。

**官方推介**
使用getDerivedStateFromProps

### componentWillUpdate
componentWillUpdate在视图更新前触发，一般用于视图更新前保存一些数据方便视图更新完成后赋值，比如列表加载更新后回到当前滚动条位置。

**问题**
由于componentWillUpdate和componentDidUpdate这两个生命周期函数有一定的时间差，会导致一些性能问题。

**官方推介**
使用getSnapshotBeforeUpdate
## MVC框架的主要问题是什么？
- 对 DOM 操作的代价非常高
- 代码耦合严重，由于循环依赖性，组件模型需要围绕 models 和 views 进行创建

## Redux遵循的三个原则是什么？ 
- **单一事实来源**：整个应用的状态存储在单个 store 中的对象/状态树里。单一状态树可以更容易地跟踪随时间的变化，并调试或检查应用程序。不像组件传来穿去的话就会有多个事实来源，很难debug而且数据流混乱。
- **状态是只读的**：改变状态的唯一方法是去触发一个动作。动作是描述变化的普通 JS 对象。就像 state 是数据的最小表示一样，该操作是对数据更改的最小表示。
- **使用纯函数进行更改**：为了指定状态树如何通过操作进行转换，你需要纯函数。纯函数是那些返回值仅取决于其参数值的函数。好处是可以track每个state的改变，容易debug。也就是**可预测**的状态变化。

拓展：redux的优势：
- **结果的可预测性**：加上reducer的pure属性，让state变化本身可预测。只存在一个真实来源，即 store ，让component拿到的状态也可预测，不存在如何将当前状态与动作和应用的其他部分同步的问题。
- **可维护性：**因为可预测，所以更可未婚。
- **易于测试：**Redux 的代码主要是小巧、纯粹和独立的功能。这使代码可测试且独立。
- **服务器端渲染**：你只需将服务器上创建的 store 传到客户端即可。这对初始渲染非常有用，并且可以优化应用性能，从而提供更好的用户体验。
- **开发人员工具**：从操作到状态更改，开发人员可以实时跟踪应用中发生的所有事情。
- **社区和生态系统**：Redux 背后有一个巨大的社区，这使得它更加迷人。一个由才华横溢的人组成的大型社区为库的改进做出了贡献，并开发了各种应用。
- **组织**：Redux 准确地说明了代码的组织方式，这使得代码在团队使用时更加一致和简单。## Redux 有哪些优点？



## references
- https://juejin.cn/post/6844903806715559943
- https://juejin.cn/post/6941546135827775525#heading-2
- https://juejin.cn/post/6844903679418433550