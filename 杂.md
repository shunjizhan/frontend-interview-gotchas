## V8的优化
### parse的执行流程
lexer也叫scanner
![Screen Shot 2021-07-30 at 15.51.07](/assets/Screen%20Shot%202021-07-30%20at%2015.51.07.png)

### JIT混合引擎
JS源代码经过了词法分析和语法分析这两个步骤，转成了字节码，其实就是经过任何一门程序语言必经的步骤：**编译**。但是不同于C++的**编译执行**(会先对bytecode进行优化），JS编译结束之后，并不会生成存放在内存或者硬盘之中的目标代码或可执行文件。生成的指令字节码Bytecode，会被立即被JSCore这台虚拟机进行逐行**解释执行**。运行指令字节码（ByteCode）是JS引擎中很核心的部分，各家JS引擎的优化也主要集中于此。

在 V8 出现之前，所有的 JavaScript 虚拟机所采用的都是解释执行的方式，这是 JavaScript 执行速度过慢的一个主要原因（没有编译执行做的优化）。而 V8 率先引入了 **即时编译（JIT）** 双轮驱动的设计。这是一种权衡策略，混合编译执行和解释执行这两种手段，给 JavaScript 的执行速度带来了极大的提升。

思路类似于用同构渲染优化SPA，就是在需要的时候做A，不需要的时候做B，而不是极端的A（SSR）或者极端的B（SPA）。就是在需要的时候优化代码，做**编译执行**，在不需要的时候，直接**解释执行**。

![Screen Shot 2021-07-30 at 15.56.16](/assets/Screen%20Shot%202021-07-30%20at%2015.56.16.png)

### JIT具体流程
Parser 将 JS 源码转换为 AST，然后 Ignition 将 AST 转换为 Bytecode，最后 TurboFan 将 Bytecode 转换为经过优化的 Machine Code(实际上是汇编代码)。
- 如果函数没有被调用，则 V8 不会去编译它。
- 如果函数只被调用 1 次，则 Ignition 将其编译 Bytecode 就直接解释执行了。TurboFan 不会进行优化编译，因为它需要 Ignition 收集函数执行时的类型信息。这就要求函数至少需要执行 1 次，TurboFan 才有可能进行优化编译。
- 如果函数被调用多次，则它有可能会被识别为`热点函数`，且 Ignition 收集的类型信息证明可以进行优化编译的话，这时 TurboFan 则会将 Bytecode 编译为 Optimized Machine Code（优化的机器码），以提高代码的执行性能。

图片中的红色虚线是逆向的，也就是说 Optimized Machine Code 会被还原为 Bytecode，这个过程叫做 「Deoptimization」。这是因为 Ignition 收集的信息可能是错误的，比如 add 函数的参数之前是整数，后来又变成了字符串。生成的 Optimized Machine Code 已经假定 add 函数的参数是整数，那当然是错误的，于是需要进行 Deoptimization。

比如：
```ts
function add(x, y) {
  return x + y;
}

add(1, 2);
add('1', '2');
```

![Screen Shot 2021-07-30 at 15.56.24](/assets/Screen%20Shot%202021-07-30%20at%2015.56.24.png)

## refenreces
- https://mp.weixin.qq.com/s/AmZGGUkeThTe4eNLCxJkRg