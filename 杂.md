## Call和Apply
用法:
```ts
fn.apply(this, argsArray);
fn.call(this, arg1, arg2, ...);
```

什么时候用什么：
A for array and C for comma，有array的时候用A（apply），有comma（很多个args）的时候用C （call）。

apply的一个方便的场景就是可以把`arguments`伪数组直接传进来。
```ts
fn.apply(this, arguments);
```

## 伪数组
伪数组 (ArrayLike) ，又称类数组。是一个类似数组的对象，但是有如下几个特征。
- 按索引方式储存数据
- 具有length属性,但是length属性不是动态的，不会随着成员的变化而改变
- 不具有数组的push()， forEach()等方法

```ts
const arrLike = {
  0: 'a',
  1: 'b',
  2: 'c',
  length: 3,
};

console.log(arrLike[0]);        // 'a'
console.log(arrLike.length);    // 3 
arrLike.push('x');              // Uncaught TypeError: arrLike.push is not a function

console.log(arrLike.__proto__ === Object.prototype);    // true
console.log(arrLike instanceof Object);                 // true
console.log(arrLike instanceof Array);                  // false
```

### 常见的伪数组
- jQuery中通过 $() 获取的DOM元素集
- 函数中的的 arguments 对象
- 以及字符串String对象
### 转化成真数组的方法
- 遍历添加进空数组
```ts
const arr = [];
for(let i = 0; i < arrLike.length; i++){
    arr.push(arrLike[i]);
}

// 简洁版，虽然有一点不一样，思路类似
Array.prototype.concat.apply([], arrayLike)
```

- 利用数组的slice()方法 (推介)
注意这个返回的数组中，不会保留索引值以外的其他额外属性。比如jQuery中$()获取的DOM伪数组，里面的context属性在被此方法转化之后就不会保留。
```ts
const arr = [].slice.call(arrLike);
// or
const arr = Array.prototype.slice.call(arrLike);
```

- 直接修改原型链，继承Array.prototype的属性，这样就能使用push()等方法。但是Array.isArray和Object.prototype.toString不认，所以只是行为上相似（不推介）
```ts
arrLike.__proto__ = Array.prototype;
```

- ES6+的Array.from()
```ts
const arr = Array.from(arrLike);
```

- ES6的spread operator
```ts
const arr = [...arrLike];
```

### arguments
`arguments`就指向该函数的Arguments对象，它是一个伪数组。arguments伪数组有很多作用：
```ts
// 1) 拿到实参的长度
function foo(b, c, d){
  console.log("实参的长度为：" + arguments.length)
}

console.log("形参的长度为：" + foo.length)

foo(1)

// 形参的长度为：3
// 实参的长度为：1

// 2) 通过callee属性可以调用函数自身
var data = [];

for (var i = 0; i < 3; i++) {
  (data[i] = function () {
    console.log(arguments.callee.i) 
  }).i = i;
}

data[0]();    // 0
data[1]();    // 1
data[2]();    // 2

// 3) 使用 apply 将 foo 的参数传递给 bar
function foo() {
  bar.apply(this, arguments);
}
function bar(a, b, c) {
  console.log(a, b, c);
}

foo(1, 2, 3)
```
## 优化
### 循环方法的使用
- 少用for of，因为会编译成带try catch的generator，非常冗余（3行变30行）。
- 少用for in，因为遍历数组的时候，除了index，还会把自己增加的属性也遍历进去
- 多用正常循环，和forEach()
```ts
const arr = ['a', 'b']
arr.c = 'c'
for (let i in arr) { console.log(i) }   // 0, 1, c
```

### 传参的优化
这个不是性能优化，但是会美化代码的结构。但是这点react源码里面都没有遵守，而且源码里面还总是用全局变量。。
```ts
const data = { x: 1, y: 2 };

const do = data => {
  // x和y都是data一部分，不需要分开传进来！
  const { x, y } = data;
}

const dont = (data, x, y) => {
  ...
}
```

### 各种遇到过的优化
在Nextjs中：
- Link组件通过预取功能（在生产环境中）自动优化应用程序以获得最佳性能
- 如果服务端需要用到node的API，比如getServerSideProps()调用fs模块，next打包客户端代码的时候，会自动treeshaking掉node相关的代码，因为客户端是不需要的。

## 数据流
数据流可以用两种处理方式
- 浏览器环境下的stream API
- `for await of`，需要对象有`Symbol.asyncIterator`

```ts
const asyncIterable = {
  [Symbol.asyncIterator]() {
    return {
      i: 0,
      next() {
        if (this.i < 3) {
          return Promise.resolve({ value: this.i++, done: false });
        }

        return Promise.resolve({ done: true });
      }
    };
  }
};

(async function() {
   for await (let num of asyncIterable) {
     console.log(num);
   }
})();
```

## 判断是不是array的四种方法
```ts
const arr = []

arr instanceof Array          // 用法：xxx instanceof constructor
arr.constructor === Array     // 假如constructor被改写了就会有问题
Object.prototype.toString.call(arr) === '[object Array]'
Array.isArray(arr)

// 注意不能用typeof判断！JS的typeof是有bug的
typeof arr === 'object' // true
typeof arr === 'array'  // false
```

## refenreces
- https://mp.weixin.qq.com/s/AmZGGUkeThTe4eNLCxJkRg
- https://stackoverflow.com/questions/1986896/what-is-the-difference-between-call-and-apply
- https://segmentfault.com/a/1190000015285969
- https://mp.weixin.qq.com/s/zVCB0Gj_yq_xNuRPW8a2iQ
