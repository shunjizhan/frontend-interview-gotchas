## V8的优化
### parse的执行流程
lexer也叫scanner
![Screen Shot 2021-07-30 at 15.51.07](/assets/Screen%20Shot%202021-07-30%20at%2015.51.07.png)

### JIT混合引擎
JS源代码经过了词法分析和语法分析这两个步骤，转成了字节码，其实就是经过任何一门程序语言必经的步骤：**编译**。但是不同于C++的**编译执行**(会先对bytecode进行优化），JS编译结束之后，并不会生成存放在内存或者硬盘之中的目标代码或可执行文件。生成的指令字节码Bytecode，会被立即被JSCore这台虚拟机进行逐行**解释执行**。运行指令字节码（ByteCode）是JS引擎中很核心的部分，各家JS引擎的优化也主要集中于此。

在 V8 出现之前，所有的 JavaScript 虚拟机所采用的都是解释执行的方式，这是 JavaScript 执行速度过慢的一个主要原因（没有编译执行做的优化）。而 V8 率先引入了 **即时编译（JIT）** 双轮驱动的设计。这是一种权衡策略，混合编译执行和解释执行这两种手段，给 JavaScript 的执行速度带来了极大的提升。

思路类似于用同构渲染优化SPA，就是在需要的时候做A，不需要的时候做B，而不是极端的A（SSR）或者极端的B（SPA）。就是在需要的时候优化代码，做**编译执行**，在不需要的时候，直接**解释执行**。

![Screen Shot 2021-07-30 at 15.56.16](/assets/Screen%20Shot%202021-07-30%20at%2015.56.16.png)

### JIT具体流程
Parser 将 JS 源码转换为 AST，然后 Ignition 将 AST 转换为 Bytecode，最后 TurboFan 将 Bytecode 转换为经过优化的 Machine Code(实际上是汇编代码)。
- 如果函数没有被调用，则 V8 不会去编译它。
- 如果函数只被调用 1 次，则 Ignition 将其编译 Bytecode 就直接解释执行了。TurboFan 不会进行优化编译，因为它需要 Ignition 收集函数执行时的类型信息。这就要求函数至少需要执行 1 次，TurboFan 才有可能进行优化编译。
- 如果函数被调用多次，则它有可能会被识别为`热点函数`，且 Ignition 收集的类型信息证明可以进行优化编译的话，这时 TurboFan 则会将 Bytecode 编译为 Optimized Machine Code（优化的机器码），以提高代码的执行性能。

图片中的红色虚线是逆向的，也就是说 Optimized Machine Code 会被还原为 Bytecode，这个过程叫做 「Deoptimization」。这是因为 Ignition 收集的信息可能是错误的，比如 add 函数的参数之前是整数，后来又变成了字符串。生成的 Optimized Machine Code 已经假定 add 函数的参数是整数，那当然是错误的，于是需要进行 Deoptimization。

比如：
```ts
function add(x, y) {
  return x + y;
}

add(1, 2);
add('1', '2');
```

![Screen Shot 2021-07-30 at 15.56.24](/assets/Screen%20Shot%202021-07-30%20at%2015.56.24.png)


## 箭头函数
箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数（不能new）。

TODO: add more

## Call和Apply
用法:
```ts
fn.apply(this, argsArray);
fn.call(this, arg1, arg2, ...);
```

什么时候用什么：
A for array and C for comma，有array的时候用A（apply），有comma（很多个args）的时候用C （call）。

apply的一个方便的场景就是可以把`arguments`伪数组直接传进来。
```ts
fn.apply(this, arguments);
```

## 伪数组
伪数组 (ArrayLike) ，又称类数组。是一个类似数组的对象，但是有如下几个特征。
- 按索引方式储存数据
- 具有length属性,但是length属性不是动态的，不会随着成员的变化而改变
- 不具有数组的push()， forEach()等方法

```ts
const arrLike = {
  0: 'a',
  1: 'b',
  2: 'c',
  length: 3,
};

console.log(arrLike[0]);        // 'a'
console.log(arrLike.length);    // 3 
arrLike.push('x');              // Uncaught TypeError: arrLike.push is not a function

console.log(arrLike.__proto__ === Object.prototype);    // true
console.log(arrLike instanceof Object);                 // true
console.log(arrLike instanceof Array);                  // false
```

### 常见的伪数组
- jQuery中通过 $() 获取的DOM元素集
- 函数中的的 arguments 对象
- 以及字符串String对象
### 转化成真数组的方法
- 遍历添加进空数组
```ts
const arr = [];
for(let i = 0; i < arrLike.length; i++){
    arr.push(arrLike[i]);
}
```

- 利用数组的slice()方法 (推介)
注意这个返回的数组中，不会保留索引值以外的其他额外属性。比如jQuery中$()获取的DOM伪数组，里面的context属性在被此方法转化之后就不会保留。
```ts
const arr = [].slice.call(arrLike);
// or
const arr = Array.prototype.slice.call(arrLike);
```

- 直接修改原型链，继承Array.prototype的属性，这样就能使用push()等方法
```ts
arrLike.__proto__ = Array.prototype;
```

- ES6+的Array.from()
```ts
const arr = Array.from(arrLike);
```
## 优化
### 循环方法的使用
- 少用for of，因为会编译成带try catch的generator，非常冗余（3行变30行）。
- 少用for in，因为遍历数组的时候，除了index，还会把自己增加的属性也遍历进去
- 多用正常循环，和forEach()
```ts
const arr = ['a', 'b']
arr.c = 'c'
for (let i in arr) { console.log(i) }   // 0, 1, c
```

### 各种遇到过的优化
在Nextjs中：
- Link组件通过预取功能（在生产环境中）自动优化应用程序以获得最佳性能
- 如果服务端需要用到node的API，比如getServerSideProps()调用fs模块，next打包客户端代码的时候，会自动treeshaking掉node相关的代码，因为客户端是不需要的。

## this
this相关
## 闭包
闭包相关

## TS相关
### interface和type有什么区别？

## 数据流
数据流可以用两种处理方式
- 浏览器环境下的stream API
- `for await of`，需要对象有`Symbol.asyncIterator`

```ts
const asyncIterable = {
  [Symbol.asyncIterator]() {
    return {
      i: 0,
      next() {
        if (this.i < 3) {
          return Promise.resolve({ value: this.i++, done: false });
        }

        return Promise.resolve({ done: true });
      }
    };
  }
};

(async function() {
   for await (let num of asyncIterable) {
     console.log(num);
   }
})();
```

## refenreces
- https://mp.weixin.qq.com/s/AmZGGUkeThTe4eNLCxJkRg
- https://stackoverflow.com/questions/1986896/what-is-the-difference-between-call-and-apply
- https://segmentfault.com/a/1190000015285969
- https://mp.weixin.qq.com/s/zVCB0Gj_yq_xNuRPW8a2iQ
